### **Documento de Diseño y Alcance: Plataforma de Gestión de Academia**

**Versión:** 1.0 **Fecha:** 24 de junio de 2024 **Autor:** Javier Dibo Gómez  
---

### **1\. Visión General y Objetivos**

#### **1.1. Visión del Producto**

El proyecto consiste en el desarrollo de una aplicación web monolítica modular, diseñada para ofrecer una solución integral a la administración, impartición y participación en cursos y talleres formativos.   
La plataforma servirá a tres roles principales: **Administradores**, **Profesores** y **Alumnos**, proporcionando a cada uno las herramientas necesarias para gestionar su experiencia en la academia de forma eficiente y centralizada.

#### **1.2. Objetivos del Negocio**

* **Centralizar la gestión:** Unificar la administración de alumnos, cursos, pagos y materiales en una única plataforma.  
* **Mejorar la experiencia del usuario:** Ofrecer a alumnos y profesores un portal intuitivo para acceder a su información, materiales y clases.  
* **Automatizar procesos:** Simplificar tareas como la inscripción, el pago de matrículas y el seguimiento de ejercicios.  
* **Crear un modelo escalable:** Construir una base tecnológica robusta que permita un crecimiento futuro de hasta 1000 usuarios mensuales y la posible adición de nuevas funcionalidades.

### 

### **2\. Alcance del Proyecto**

#### **2.1. Funcionalidades Principales (En Alcance)**

**Módulo de Usuarios:**

* Registro y autenticación de usuarios (Alumnos, Profesores).  
* Gestión de perfiles de usuario.  
* Sistema de roles y permisos (Administrador, Profesor, Alumno).  
* Funcionalidad de "resetear contraseña" mediante correo electrónico.

**Módulo de Academia (Administrador):**

* Gestión (CRUD) de Cursos y Talleres.  
* Gestión (CRUD) de Profesores y Alumnos.  
* Asignación de profesores a clases.  
* Dashboard con métricas clave (alumnos matriculados, ingresos, etc.).  
* Supervisión de pagos  
  * Registrar un pago manualmente, gestionar reembolsos, vista global

**Módulo del Profesor:**

* Visualización de las clases asignadas y la lista de alumnos inscritos.  
* Subida y gestión de Materiales de clase (documentos, enlaces).  
* Creación y gestión de Ejercicios.  
* Calificación de los ejercicios entregados por los alumnos.

**Módulo del Alumno:**

* Catálogo de Cursos y Talleres disponibles.  
* Proceso de inscripción y matriculación en clases.  
* Acceso a sus clases, materiales y ejercicios.  
* Subida de archivos para la entrega de ejercicios.  
* Historial de pagos y estado de la matrícula.

**Módulo de Pagos:**

* Integración con **Stripe** para procesar pagos de matrículas, cursos y talleres.  
* Soporte para pagos con tarjeta de crédito/débito.  
* Registro y seguimiento del estado de cada pago (éxito, error).  
* Implementar un webhook para escuchar eventos de `payment_intent.succeeded` de Stripe.

**Módulo de Email**:

* Usar **Spring Boot Mail** con un proveedor como **SendGrid**, **Mailgun** o **AWS SES**.

**Módulo de Facturación (en alcance):**

* Generación automática de facturas en PDF tras un pago exitoso.  
* Numeración de facturas secuencial y única.  
* Almacenamiento seguro de facturas en un servicio de almacenamiento en la nube (ej. AWS S3).  
* Envío de la factura por correo electrónico al alumno.  
* Disponibilidad de la factura para su descarga en el historial de pagos del alumno

#### 

#### **2.2. Fuera del Alcance (Versión Inicial)**

* Blog  
* Integración con calendarios externos (Google Calendar, Outlook)  
* App móvil nativa  
* Clases en vivo (integración con Zoom, etc.)  
* Anuncio  
  * **Anuncio tendría:** id, titulo, contenido, fechaPublicacion, profesorId, claseId.  
  * **Funcionalidad:** Un profesor puede publicar un anuncio en el tablón de una de sus clases. Los alumnos de esa clase lo ven al entrar. Es mucho más simple que un chat o un foro y aporta un gran valor.

### **3\. Requisitos No Funcionales**

#### **3.1. Rendimiento**

* La aplicación debe soportar entre **100 usuarios concurrentes** sin una degradación notable del rendimiento.  
* El tiempo de carga de las páginas principales no debe superar los 2 segundos en una conexión de banda ancha estándar.

#### **3.2. Seguridad**

* **Autenticación y Autorización:** Se implementará con **Spring Security**. Las contraseñas se almacenarán hasheadas usando `BCryptPasswordEncoder`.  
  * Se utilizará un chequeo del hashing al iniciar sesión y se expedirá un token de JWT válido hasta que finalice la sesión, es decir, un timeout o un logout.  
* **Protección de Datos:** Todo el tráfico entre el cliente y el servidor se realizará a través de **HTTPS**.  
* **Pagos:** La gestión de datos de tarjetas de crédito será delegada completamente a **Stripe**, asegurando el cumplimiento de la normativa **PCI-DSS**. La aplicación solo almacenará el identificador de la transacción y su estado.  
* **Prevención de Vulnerabilidades:** Se aplicarán las mejores prácticas para prevenir ataques comunes como XSS, CSRF e Inyección SQL (Hibernate/JPA ayuda a mitigar esto último).  
* **CORS**: Se configurará para solo permitir peticiones del frontend.  
* **Validación de datos:** Anotaciones en los DTOs y @Valid en los controladores.  
- [ ] SEGURIDAD: Revisar sugerencias (abajo de esta tarea)  
* **Rate Limiting:** Menciona la implementación de limitación de peticiones (rate limiting) en endpoints críticos como el login y el reseteo de contraseña para prevenir ataques de fuerza bruta. Librerías como Bucket4j se integran bien con Spring Boot.  
* **Gestión de Secretos:** ¿Cómo se gestionarán las claves de API (Stripe, SendGrid), contraseñas de la base de datos, etc.? Mencionar el uso de variables de entorno o un sistema de gestión de secretos (como GitHub Secrets para Actions, o Vault) fortalecería esta sección.


#### **3.3. Cumplimiento Normativo (LOPD/RGPD)**

* Se solicitará consentimiento explícito del usuario para el tratamiento de sus datos durante el registro.  
* Se proporcionará una página de Política de Privacidad y Términos de Servicio.  
* Los usuarios podrán ejercer sus derechos ARCO (Acceso, Rectificación, Cancelación y Oposición). Se implementará una funcionalidad para que el usuario pueda solicitar la eliminación de su cuenta y datos personales.  
* El acceso a los datos personales estará restringido por roles.

#### **3.4. Usabilidad y Accesibilidad**

* La interfaz será responsive, adaptándose a dispositivos de escritorio y móviles.  
* Se seguirán pautas básicas de accesibilidad (WCAG) para garantizar que la plataforma pueda ser utilizada por el mayor número de personas posible.

### 

### **4\. Arquitectura de la Aplicación**

#### **4.1. Descripción General**

Se opta por una arquitectura de **Monolito Modular** para equilibrar la simplicidad de despliegue de un monolito con la organización y el bajo acoplamiento de los microservicios.

* **Frontend:** Aplicación de Página Única (SPA) desarrollada con **Svelte** y estilada con **Tailwind CSS**. Se usarán componentes de **Flowbite** y **shadcn-svelte** para acelerar el desarrollo. La comunicación con el backend será a través de una API RESTful usando **axios**.  
* **Backend:** Aplicación monolítica escrita en **Java** con **Spring Boot**. La lógica de negocio se separará en módulos (usuarios, cursos, pagos). Se usará **Spring Data JPA (Hibernate)** para la persistencia.  
* **Base de Datos:** **PostgreSQL**, una base de datos relacional robusta y de código abierto.  
* **Servicio de Pagos:** **Stripe**, como pasarela de pago externa.  
* **Good to haves:** Lombok y Spring Boot DevTools

#### **4.2. Versiones**

**Java (JDK)** 21 LTS   
**Spring Boot** 3.5  
**PostgreSQL** 16  
**Node.js** 20 LTS  
**Svelte,** 5  
**Tailwind CSS,** 4  
**Docker** 28

### 

### **6\. Plan de Despliegue y Operaciones (DevOps)**

#### **6.1. Entornos**

* **Desarrollo:** Entorno local usando **Docker Compose** para levantar la base de datos PostgreSQL.  
* **Staging/Pruebas:** Un entorno idéntico a producción para realizar pruebas de integración y aceptación.  
* **Producción:** Despliegue final para los usuarios.

#### **6.2. CI/CD**

* Se utilizará **GitHub Actions** para automatizar el proceso de integración y despliegue continuo.  
* **Flujo de CI:** En cada `push` a las ramas `main` o `develop`, se ejecutarán tests unitarios y de integración. El código será compilado y analizado en busca de vulnerabilidades.  
* **Flujo de CD:** Tras un `merge` exitoso a la rama `main`, se construirá una imagen **Docker** de la aplicación backend y se desplegará automáticamente en **Cloud Foundry**. El frontend se desplegará en **Vercel**.

#### **6.3. POR DEFINIR Monitorización y Logging** 

- [ ] LOGGING: Definir logging  
- [ ] LOGGING: Investigar el módulo **Micrometer Registry Prometheus**

Usar **Spring Boot Starter Actuator**

**Recomendaciones por la IA sin revisar:**

* **JSON Formatting:** Configurar Spring Boot para que escriba los logs en formato JSON.   
  * Esto hace que sean mucho más fáciles de parsear, filtrar y buscar en Loki/Kibana. Puedes usar librerías como logstash-logback-encoder.  
* **Métricas de Aplicación (APM):**  
  * Se utilizará **Spring Boot Actuator** para exponer métricas de la JVM, peticiones HTTP, etc.  
  * Se integrará con la pila **Prometheus** (para la recolección de métricas) y **Grafana** (para la visualización y creación de dashboards). Esta es la opción open-source más potente y estándar en la industria.  
  * **Qué monitorizar** (Dashboards en Grafana):   
    * Métricas de la JVM: Uso de Heap, hilos, recolección de basura. Actuator te da esto gratis.   
    * Métricas de la Aplicación (RED): Para tus endpoints de API: Rate (peticiones por segundo), Errors (tasa de errores 5xx, 4xx), Duration (latencia de las peticiones).   
    * Métricas de Negocio: ¡Esto es clave\! Crea métricas personalizadas con Micrometer para monitorizar: Nuevos registros de usuarios. Inscripciones a cursos por día. Pagos procesados (éxito vs. error).  
* **Logging Centralizado:**  
  * Los logs generados por Spring Boot serán enviados a un sistema de logging centralizado como la pila **ELK (Elasticsearch, Logstash, Kibana)** o **Loki** (que se integra muy bien con Grafana). Esto permite buscar y analizar logs de forma eficiente sin tener que acceder al servidor.  
* **Alertas:**  
  * Se configurarán alertas en Grafana/Alertmanager para notificar al equipo (por email o Slack) sobre condiciones anómalas (ej. alta latencia, tasa de errores elevada, uso de CPU al 95%).  
  * **Herramienta:** **Prometheus Alertmanager** es la pieza que falta en tu descripción. Se integra con Prometheus para enviar notificaciones.  
  * **Tipos de Alertas:**  
    * **Técnicas:** "La CPU del contenedor lleva 5 minutos por encima del 90%", "La tasa de errores 5xx ha superado el 5%", "El disco está al 85% de su capacidad".  
    * **De Negocio:** "La tasa de fallos en los pagos de Stripe ha superado el 10% en la última hora" (¡esto podría indicar un problema grave\!).

